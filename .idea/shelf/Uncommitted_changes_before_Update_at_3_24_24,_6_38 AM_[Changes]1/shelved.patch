Index: src/Image.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// Created by Mustafa M on 3/18/2024.\r\n//\r\n\r\n#include \"Image.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\nImage* deepCopy(const Image* src) {\r\n    Image* copy = new Image;\r\n    copy->header = src->header; // Copy header\r\n    copy->pixels = new Pixel*[copy->header.height];\r\n    for (int i = 0; i < copy->header.height; i++) {\r\n        copy->pixels[i] = new Pixel[copy->header.width];\r\n        for (int j = 0; j < copy->header.width; j++) {\r\n            copy->pixels[i][j] = src->pixels[i][j]; // Copy pixel data\r\n        }\r\n    }\r\n    return copy;\r\n}\r\n\r\nImage* readFile(const std::string filename) {\r\n    std::ifstream file(filename, std::ios::in | std::ios::binary);\r\n    if (!file.is_open()) {\r\n        std::cout << \"Error: File not found\" << std::endl;\r\n        return nullptr;\r\n    }\r\n    Image *img = new Image;\r\n    readData(file, img);\r\n    file.close();\r\n    return img;\r\n}\r\n\r\nvoid readData(std::ifstream &file, Image* img) {\r\n    // Directly modify *img...\r\n    file.read(&img->header.idLength, sizeof(img->header.idLength));\r\n    file.read(&img->header.colorMapType, sizeof(img->header.colorMapType));\r\n    file.read(&img->header.dataTypeCode, sizeof(img->header.dataTypeCode));\r\n    file.read(reinterpret_cast<char*>(&img->header.colorMapOrigin), sizeof(img->header.colorMapOrigin));\r\n    file.read(reinterpret_cast<char*>(&img->header.colorMapLength), sizeof(img->header.colorMapLength));\r\n    file.read(&img->header.colorMapDepth, sizeof(img->header.colorMapDepth));\r\n    file.read(reinterpret_cast<char*>(&img->header.xOrigin), sizeof(img->header.xOrigin));\r\n    file.read(reinterpret_cast<char*>(&img->header.yOrigin), sizeof(img->header.yOrigin));\r\n    file.read(reinterpret_cast<char*>(&img->header.width), sizeof(img->header.width));\r\n    file.read(reinterpret_cast<char*>(&img->header.height), sizeof(img->header.height));\r\n    file.read(&img->header.bitsPerPixel, sizeof(img->header.bitsPerPixel));\r\n    file.read(&img->header.imageDescriptor, sizeof(img->header.imageDescriptor));\r\n\r\n    img->pixels = new Pixel*[img->header.height];\r\n    for (int i = 0; i < img->header.height; i++) {\r\n        img->pixels[i] = new Pixel[img->header.width];\r\n        for (int j = 0; j < img->header.width; j++) {\r\n            file.read(reinterpret_cast<char*>(&img->pixels[i][j].blue), sizeof(unsigned char));\r\n            file.read(reinterpret_cast<char*>(&img->pixels[i][j].green), sizeof(unsigned char));\r\n            file.read(reinterpret_cast<char*>(&img->pixels[i][j].red), sizeof(unsigned char));\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid writeData(const Image& image, const std::string& filename) {\r\n    std::ofstream file(filename, std::ios::out | std::ios::binary);\r\n    if (!file.is_open()) {\r\n        std::cerr << \"Error: Could not open file for writing - \" << filename << std::endl;\r\n        return;\r\n    }\r\n\r\n    file.write(&image.header.idLength, sizeof(image.header.idLength));\r\n    file.write(&image.header.colorMapType, sizeof(image.header.colorMapType));\r\n    file.write(&image.header.dataTypeCode, sizeof(image.header.dataTypeCode));\r\n    file.write(reinterpret_cast<const char*>(&image.header.colorMapOrigin), sizeof(image.header.colorMapOrigin));\r\n    file.write(reinterpret_cast<const char*>(&image.header.colorMapLength), sizeof(image.header.colorMapLength));\r\n    file.write(&image.header.colorMapDepth, sizeof(image.header.colorMapDepth));\r\n    file.write(reinterpret_cast<const char*>(&image.header.xOrigin), sizeof(image.header.xOrigin));\r\n    file.write(reinterpret_cast<const char*>(&image.header.yOrigin), sizeof(image.header.yOrigin));\r\n    file.write(reinterpret_cast<const char*>(&image.header.width), sizeof(image.header.width));\r\n    file.write(reinterpret_cast<const char*>(&image.header.height), sizeof(image.header.height));\r\n    file.write(&image.header.bitsPerPixel, sizeof(image.header.bitsPerPixel));\r\n    file.write(&image.header.imageDescriptor, sizeof(image.header.imageDescriptor));\r\n\r\n    for (int i = 0; i < image.header.height; i++) {\r\n        for (int j = 0; j < image.header.width; j++) {\r\n            file.write(reinterpret_cast<char*>(&image.pixels[i][j].blue), sizeof(image.pixels[i][j].blue));\r\n            file.write(reinterpret_cast<char*>(&image.pixels[i][j].green), sizeof(image.pixels[i][j].green));\r\n            file.write(reinterpret_cast<char*>(&image.pixels[i][j].red), sizeof(image.pixels[i][j].red));\r\n        }\r\n    }\r\n\r\n    file.close();\r\n}\r\n\r\nImage* multiply(Image& image1, Image& image2) {\r\n    auto* result = new Image;\r\n    result->header = image1.header;\r\n    result->pixels = new Pixel*[result->header.height];\r\n\r\n    for (int i = 0; i < result->header.height; i++) {\r\n        result->pixels[i] = new Pixel[result->header.width];\r\n        for (int j = 0; j < result->header.width; j++) {\r\n            // Normalizing color values to [0, 1], performing multiplication, and rescaling back to [0, 255]\r\n            float blue1 = image1.pixels[i][j].blue / 255.0f;\r\n            float green1 = image1.pixels[i][j].green / 255.0f;\r\n            float red1 = image1.pixels[i][j].red / 255.0f;\r\n\r\n            float blue2 = image2.pixels[i][j].blue / 255.0f;\r\n            float green2 = image2.pixels[i][j].green / 255.0f;\r\n            float red2 = image2.pixels[i][j].red / 255.0f;\r\n\r\n            result->pixels[i][j].blue = static_cast<unsigned char>((blue1 * blue2) * 255 + 0.5);\r\n            result->pixels[i][j].green = static_cast<unsigned char>((green1 * green2) * 255 + 0.5);\r\n            result->pixels[i][j].red = static_cast<unsigned char>((red1 * red2) * 255 + 0.5);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nImage* subtract( Image& image1,  Image& image2) {\r\n    auto* result = new Image();\r\n    result->header = image1.header; // Assuming both images have the same dimensions and format\r\n\r\n    result->pixels = new Pixel*[result->header.height];\r\n    for (int i = 0; i < result->header.height; i++) {\r\n        result->pixels[i] = new Pixel[result->header.width];\r\n    }\r\n\r\n    for (int i = 0; i < result->header.height; i++) {\r\n        for (int j = 0; j < result->header.width; j++) {\r\n            // Ensure subtraction results are clamped to 0 if negative or minimal positive values\r\n            result->pixels[i][j].blue = std::max(0, image2.pixels[i][j].blue - image1.pixels[i][j].blue);\r\n            result->pixels[i][j].green = std::max(0, image2.pixels[i][j].green - image1.pixels[i][j].green);\r\n            result->pixels[i][j].red = std::max(0, image2.pixels[i][j].red - image1.pixels[i][j].red);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nImage* screen(Image& bottomLayer, Image& topLayer) {\r\n    // Ensure the dimensions of both images match\r\n    auto* result = new Image();\r\n    result->header = bottomLayer.header; // Assuming both images have the same header\r\n    result->pixels = new Pixel*[result->header.height];\r\n\r\n    for (int i = 0; i < result->header.height; ++i) {\r\n        result->pixels[i] = new Pixel[result->header.width];\r\n        for (int j = 0; j < result->header.width; ++j) {\r\n            // Normalize the pixel values to [0, 1] for calculation\r\n            float bottomBlue = bottomLayer.pixels[i][j].blue / 255.0f;\r\n            float bottomGreen = bottomLayer.pixels[i][j].green / 255.0f;\r\n            float bottomRed = bottomLayer.pixels[i][j].red / 255.0f;\r\n\r\n            float topBlue = topLayer.pixels[i][j].blue / 255.0f;\r\n            float topGreen = topLayer.pixels[i][j].green / 255.0f;\r\n            float topRed = topLayer.pixels[i][j].red / 255.0f;\r\n\r\n            // Apply the screen blending mode formula for each color channel\r\n            result->pixels[i][j].blue = (1 - (1 - topBlue) * (1 - bottomBlue)) * 255;\r\n            result->pixels[i][j].green = (1 - (1 - topGreen) * (1 - bottomGreen)) * 255;\r\n            result->pixels[i][j].red = (1 - (1 - topRed) * (1 - bottomRed)) * 255;\r\n\r\n            // Clamp the results to the range [0, 255]\r\n            result->pixels[i][j].blue = std::min(std::max(int(result->pixels[i][j].blue + 0.5), 0), 255);\r\n            result->pixels[i][j].green = std::min(std::max(int(result->pixels[i][j].green + 0.5), 0), 255);\r\n            result->pixels[i][j].red = std::min(std::max(int(result->pixels[i][j].red + 0.5), 0), 255);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nImage* combine(const Image* trackingImage, const std::string& greenLayerPath, const std::string& blueLayerPath) {\r\n    // First, make a deep copy of the trackingImage to work on\r\n    Image* combinedImage = deepCopy(trackingImage);\r\n\r\n    // Load the green layer\r\n    Image* greenLayer = readFile(greenLayerPath);\r\n    if (!greenLayer) {\r\n        std::cerr << \"File does not exist: \" << greenLayerPath << std::endl;\r\n        delete combinedImage; // Clean up the combined image before returning\r\n        return nullptr;\r\n    }\r\n\r\n    // Load the blue layer\r\n    Image* blueLayer = readFile(blueLayerPath);\r\n    if (!blueLayer) {\r\n        std::cerr << \"File does not exist: \" << blueLayerPath << std::endl;\r\n        delete greenLayer; // Clean up the green layer before returning\r\n        delete combinedImage; // Clean up the combined image before returning\r\n        return nullptr;\r\n    }\r\n\r\n    // Assuming all images have the same dimensions and format\r\n    for (int i = 0; i < combinedImage->header.height; i++) {\r\n        for (int j = 0; j < combinedImage->header.width; j++) {\r\n            // The red channel stays as is from the trackingImage copy\r\n            // Update the green and blue channels from the loaded layers\r\n            combinedImage->pixels[i][j].green = greenLayer->pixels[i][j].green;\r\n            combinedImage->pixels[i][j].blue = blueLayer->pixels[i][j].blue;\r\n        }\r\n    }\r\n\r\n    // Clean up the dynamically allocated green and blue layer images\r\n    delete greenLayer;\r\n    delete blueLayer;\r\n\r\n    // Return the new image with combined channels\r\n    return combinedImage;\r\n}\r\n\r\n\r\n// overlay formula:\r\n// {\r\n// NP2 <= 0.5: 2 * NP1 * NP2\r\n// NP2 > 0.5: 1 - 2 * (1 - NP1) * (1 - NP2)\r\n// }\r\n\r\ntemplate <typename T>\r\nT clamp(T value, float low, float high) {\r\n    return (value < low) ? low : (value > high) ? high : value;\r\n}\r\n//Image* overlay(Image& baseLayer, Image& blendLayer) {\r\n//    auto* result = new Image();\r\n//    result->header = baseLayer.header; // Assuming both images have the same dimensions and format.\r\n//    result->pixels = new Pixel*[result->header.height];\r\n//\r\n//    for (int i = 0; i < result->header.height; ++i) {\r\n//        result->pixels[i] = new Pixel[result->header.width];\r\n//        for (int j = 0; j < result->header.width; ++j) {\r\n//            float baseBlue = baseLayer.pixels[i][j].blue / 255.0f;\r\n//            float baseGreen = baseLayer.pixels[i][j].green / 255.0f;\r\n//            float baseRed = baseLayer.pixels[i][j].red / 255.0f;\r\n//\r\n//            float blendBlue = blendLayer.pixels[i][j].blue / 255.0f;\r\n//            float blendGreen = blendLayer.pixels[i][j].green / 255.0f;\r\n//            float blendRed = blendLayer.pixels[i][j].red / 255.0f;\r\n//\r\n//            result->pixels[i][j].blue = (blendBlue <= 0.5) ?\r\n//                                        (2 * baseBlue * blendBlue) :\r\n//                                        (1 - 2 * (1 - baseBlue) * (1 - blendBlue));\r\n//            result->pixels[i][j].green = (blendGreen <= 0.5) ?\r\n//                                         (2 * baseGreen * blendGreen) :\r\n//                                         (1 - 2 * (1 - baseGreen) * (1 - blendGreen));\r\n//            result->pixels[i][j].red = (blendRed <= 0.5) ?\r\n//                                       (2 * baseRed * blendRed) :\r\n//                                       (1 - 2 * (1 - baseRed) * (1 - blendRed));\r\n//\r\n//            // Clamping the results back to the 0-255 range.\r\n//            result->pixels[i][j].blue = clamp(result->pixels[i][j].blue * 255, 0.0f, 255.0f);\r\n//            result->pixels[i][j].green = clamp(result->pixels[i][j].green * 255, 0.0f, 255.0f);\r\n//            result->pixels[i][j].red = clamp(result->pixels[i][j].red * 255, 0.0f, 255.0f);\r\n//        }\r\n//    }\r\n//\r\n//    return result;\r\n//}\r\n\r\n\r\n\r\n// addition formula: P1 + P2\r\nImage* addition(Image& image1, Image& image2) {\r\n    auto* result = new Image;\r\n    *result = image1;\r\n\r\n    for (int i = 0; i < result->header.height; i++) {\r\n        for (int j = 0; j < result->header.width; j++) {\r\n            result->pixels[i][j].blue = min(255, image1.pixels[i][j].blue + image2.pixels[i][j].blue);\r\n            result->pixels[i][j].green = min(255, image1.pixels[i][j].green + image2.pixels[i][j].green);\r\n            result->pixels[i][j].red = min(255, image1.pixels[i][j].red + image2.pixels[i][j].red);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nImage* overlay(Image& topLayer, Image& bottomLayer) {\r\n    // Assuming both images have the same dimensions and format\r\n    auto* result = new Image();\r\n    result->header = topLayer.header;\r\n    result->pixels = new Pixel*[result->header.height];\r\n\r\n    for (int i = 0; i < result->header.height; ++i) {\r\n        result->pixels[i] = new Pixel[result->header.width];\r\n        for (int j = 0; j < result->header.width; ++j) {\r\n            // Normalize pixel values to the range [0, 1] for the calculation\r\n            float topBlue = topLayer.pixels[i][j].blue / 255.0f;\r\n            float topGreen = topLayer.pixels[i][j].green / 255.0f;\r\n            float topRed = topLayer.pixels[i][j].red / 255.0f;\r\n\r\n            float bottomBlue = bottomLayer.pixels[i][j].blue / 255.0f;\r\n            float bottomGreen = bottomLayer.pixels[i][j].green / 255.0f;\r\n            float bottomRed = bottomLayer.pixels[i][j].red / 255.0f;\r\n\r\n            // Apply overlay blending mode for each channel\r\n            result->pixels[i][j].blue = bottomBlue <= 0.5 ?\r\n                                        2 * topBlue * bottomBlue * 255 :\r\n                                        (1 - 2 * (1 - topBlue) * (1 - bottomBlue)) * 255;\r\n\r\n            result->pixels[i][j].green = bottomGreen <= 0.5 ?\r\n                                         2 * topGreen * bottomGreen * 255 :\r\n                                         (1 - 2 * (1 - topGreen) * (1 - bottomGreen)) * 255;\r\n\r\n            result->pixels[i][j].red = bottomRed <= 0.5 ?\r\n                                       2 * topRed * bottomRed * 255 :\r\n                                       (1 - 2 * (1 - topRed) * (1 - bottomRed)) * 255;\r\n\r\n            // Clamp the results to [0, 255]\r\n            result->pixels[i][j].blue = std::min(std::max(int(result->pixels[i][j].blue + 0.5f), 0), 255);\r\n            result->pixels[i][j].green = std::min(std::max(int(result->pixels[i][j].green + 0.5f), 0), 255);\r\n            result->pixels[i][j].red = std::min(std::max(int(result->pixels[i][j].red + 0.5f), 0), 255);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Image.cpp b/src/Image.cpp
--- a/src/Image.cpp	
+++ b/src/Image.cpp	
@@ -173,7 +173,7 @@
     return result;
 }
 
-Image* combine(const Image* trackingImage, const std::string& greenLayerPath, const std::string& blueLayerPath) {
+Image* combine( Image* trackingImage, std::string& greenLayerPath, std::string& blueLayerPath) {
     // First, make a deep copy of the trackingImage to work on
     Image* combinedImage = deepCopy(trackingImage);
 
Index: src/Image.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <algorithm> // For std::min\r\n\r\nstruct Header {\r\n    char idLength;\r\n    char colorMapType;\r\n    char dataTypeCode;\r\n    short colorMapOrigin;\r\n    short colorMapLength;\r\n    char colorMapDepth;\r\n    short xOrigin;\r\n    short yOrigin;\r\n    short width;\r\n    short height;\r\n    char bitsPerPixel;\r\n    char imageDescriptor;\r\n};\r\n\r\nstruct Pixel {\r\n    unsigned char blue;\r\n    unsigned char green;\r\n    unsigned char red;\r\n};\r\n\r\nstruct Image {\r\n    Header header;\r\n    Pixel **pixels;\r\n\r\n    ~Image() { // Destructor to free allocated memory\r\n        if (pixels) {\r\n            for (int i = 0; i < header.height; ++i) {\r\n                delete[] pixels[i];\r\n            }\r\n            delete[] pixels;\r\n        }\r\n    }\r\n};\r\n\r\nImage* readFile( std::string filename);\r\nvoid readData(std::ifstream& file, Image* img);\r\nvoid writeData(const Image& image, const std::string& filename);\r\nImage* multiply( Image& image1,  Image& image2);\r\nImage* screen( Image& image1,  Image& image2);\r\nImage* subtract( Image& image1,  Image& image2);\r\nImage* addition( Image& image1,  Image& image2);\r\nImage* overlay( Image& image1,  Image& image2);\r\n// void combine(Image*& trackingImage, const std::string& greenLayerPath, const std::string& blueLayerPath) {\r\nImage* combine(Image* trackingImage, const std::string& greenLayerPath, const std::string& blueLayerPath);
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Image.h b/src/Image.h
--- a/src/Image.h	
+++ b/src/Image.h	
@@ -47,4 +47,4 @@
 Image* addition( Image& image1,  Image& image2);
 Image* overlay( Image& image1,  Image& image2);
 // void combine(Image*& trackingImage, const std::string& greenLayerPath, const std::string& blueLayerPath) {
-Image* combine(Image* trackingImage, const std::string& greenLayerPath, const std::string& blueLayerPath);
\ No newline at end of file
+Image* combine(Image* trackingImage, std::string& greenLayerPath, std::string& blueLayerPath);
\ No newline at end of file
Index: .gitignore
===================================================================
diff --git a/.gitignore b/.gitignore
new file mode 100644
--- /dev/null	
+++ b/.gitignore	
@@ -0,0 +1,3 @@
+CMakeLists.txt
+src/main_deprecated.cpp
+src/commands.txt
Index: .idea/vcs.xml
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/vcs.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
